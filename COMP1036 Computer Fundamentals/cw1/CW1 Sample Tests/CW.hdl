//    scyxxx    2051xxxx    YourName
//    Filename:    CW.hdl
/*
    *    
    *    it    is    the    main    chip    to    finish    the    cw
*/
CHIP    CW{
    IN    
    inID[16],inMARK[16],
    load,
    probe,
    address[2],
    sl,
    priority[2];
    OUT
    outID[16],
    outMARK[16],
    sum[16],
    avg[16],
    overflow;
    PARTS:    

    // CHECK Priority For Output
    // Eq to 0 - 0 0
    Or(a=priority[0], b=priority[1], out=OrPriority0);
    Not(in=OrPriority0, out=isEqual0);
    // Eq to 1 - 0 1
    Not(in=priority[1], out=notPriority1);
    And(a=notPriority1, b=priority[0], out=isEqual1);
    // Eq to 2 - 1 0
    Not(in=priority[0], out=notPriority2);
    And(a=notPriority2, b=priority[1], out=isEqual2);
    // Eq to 3 - 1 1
    And(a=priority[0], b=priority[1], out=isEqual3);

    // CONTROL Out - Only Output ID / MARK When priority = 0 and Probe = 1
    And(a=isEqual0, b=probe, out=onlyOutIDMark);

    // DEFINE 4 registers for storing ID and 4 registers for storing mark
    Register(in=inID, load=id0, out=oi0);
    Register(in=inID, load=id1, out=oi1);
    Register(in=inID, load=id2, out=oi2);
    Register(in=inID, load=id3, out=oi3);

    Register(in=inMARK, load=mk0, out=om0);
    Register(in=inMARK, load=mk1, out=om1);
    Register(in=inMARK, load=mk2, out=om2);
    Register(in=inMARK, load=mk3, out=om3);

    // Load Logic
    DMux4Way(in=load, sel=address, a=id0, b=id1, c=id2, d=id3);
    DMux4Way(in=load, sel=address, a=mk0, b=mk1, c=mk2, d=mk3);

    // Out Logic
    Mux4Way16(a=oi0, b=oi1, c=oi2, d=oi3, sel=address, out=o1);
    Mux4Way16(a=om0, b=om1, c=om2, d=om3, sel=address, out=o2);

    Mux16(a=false, b=o1, sel=onlyOutIDMark, out=outID);
    Mux16(a=false, b=o2, sel=onlyOutIDMark, out=outMARK);

    //TASK 2
    Not(in=sl, out=isNotSL);
    And(a=load, b=isNotSL, out=isOnlyLoad);
    And(a=load, b=sl, out=isSLLoad);
    //SAM

    
    // SUM Marks
    Add16(a=om0, b=om1, out=sumR01);
    Add16(a=sumR01, b=om2, out=sumR012);
    Add16(a=sumR012, b=om3, out=sumR0123);
    // OVERFLOW Check
    
    Mux16(a=false, b=sumR0123, sel=isEqual1, out=sum);

    // SIMPLE AVERAGE - DIVIDE BY 4 (Shift Right 2 times)
    ShiftRight(in=sumR0123, out=sumR0123D2);
    ShiftRight(in=sumR0123D2, out=sumR0123D4);

    // OUT AVERAGE
    Mux16(a=false, b=sumR0123D4, sel=isEqual2, out=avg);

    // REAL AVERAGE
    
}